##############################
### PowerShell One-Liners  ###
##############################
# These one-line commands are intended to be used in a PowerShell session. They are written so that you can get maximum benefit, often with minimum typing and without having to write a script. 
# Because these are intended for use at the command prompt aliases are allowed and encouraged. I’ll assume you can figure out the alias if you don’t recognize it.
# As written, many of them should not be copied and pasted into a script without reworking. Note that some of these expressions will work on Windows PowerShell and PowerShell 7 or require a Windows platform. 
# You’ll have to try them out for yourself and adjust as necessary. You’ll need to add things like parameters and error handling. It may also be easier to break some of these into several steps when used in a script.

#############################################################
# Get the scriptblock content of a loaded function. Substitute the name of a function.
#
(get-item Function:\prompt).scriptblock

#############################################################
# Copy a function to a remote computer using a PSSession.
#
$f = $(get-item function:\Get-Foo).scriptblock
Invoke-Command { New-Item -Name Get-Foo -Path Function: -Value $($using:f)} -session $s

#############################################################
# Get running scheduled tasks on a Windows system.
#
(get-scheduledtask).where({$_.state -eq 'running'})

#############################################################
# Get system uptime from multiple computers where $computers is an array of computer names running PowerShell v3 or later.
#
Get-CimInstance Win32_operatingsystem <# -ComputerName $computers #> |
Select-Object PSComputername,LastBootUpTime,
@{Name="Uptime";Expression = {(Get-Date) - $_.LastBootUptime}}

#############################################################
# Another way to get drive utilization using PSDrives.
#
Get-PSDrive -PSProvider filesystem | where-object {$_.used -gt 0} |
select-Object -property Root,@{name="SizeGB";expression={($_.used+$_.free)/1GB -as [int]}},
@{name="UsedGB";expression={($_.used/1GB) -as [int]}},
@{name="FreeGB";expression={($_.free/1GB) -as [int]}},
@{name="PctFree";expression={[math]::round(($_.free/($_.used+$_.free))*100,2)}}



#############################################################
# Work with quotes
#

$foo = 1,2,3
"$foo[1]"     # yields "1 2 3[1]"
"$($foo[1])"  # yields "2"

$bar = "abc"
"$bar.Length"    # yields "abc.Length"
"$($bar.Length)" # yields "3"


#############################################################
# List installed applications and a few details. But use with caution. It is slow, not necessarily complete, and could have unexpected consequences. Heres a good link about using this class and alternatives.
#
gcim win32_product <# -ComputerName $env:computername #>  | 
Sort-Object -property Vendor,Name | <# Select-Object #> Format-Table -property <#Vendor,#> Name,Version,
@{Name="Installed";Expression = {($_.InstallDate.Insert(4,"-").insert(7,"-") -as [datetime]).ToShortDateString()}},
@{Name="InstallSource";Expression = {$_.InstallSource+$_.PackageName}},
InstallLocation

#############################################################
# Get details about all external scripts in your %PATH%.
#
gcm -commandtype externalscript | Get-Item | 
Select-Object Directory,Name,Length,CreationTime,LastwriteTime,
@{name="Signature";Expression={(Get-AuthenticodeSignature $_.fullname).Status }}


#############################################################
# Get Computer Serial Number
(Get-WmiObject win32_bios).serialnumber                   
GC70G73

PS C:\home\src\Scripts> (Get-WmiObject win32_bios) | Select *


RunspaceId                     : d11ccdb2-1b0d-434f-be08-a69a58103adc
__GENUS                        : 2
__CLASS                        : Win32_BIOS
__SUPERCLASS                   : CIM_BIOSElement
__DYNASTY                      : CIM_ManagedSystemElement
__RELPATH                      : Win32_BIOS.Name="2.14.0",SoftwareElementID="2.14.0",SoftwareElementState=3,TargetOperatingSystem=0,Version="DELL   - 1072009"
__PROPERTY_COUNT               : 31
__DERIVATION                   : {CIM_BIOSElement, CIM_SoftwareElement, CIM_LogicalElement, CIM_ManagedSystemElement}
__SERVER                       : WIN11-2
__NAMESPACE                    : root\cimv2
__PATH                         : \\WIN11-2\root\cimv2:Win32_BIOS.Name="2.14.0",SoftwareElementID="2.14.0",SoftwareElementState=3,TargetOperatingSystem=0,Version="DELL   - 1072009"
BiosCharacteristics            : {7, 9, 11, 12…}
BIOSVersion                    : {DELL   - 1072009, 2.14.0, American Megatrends - 5000F}
BuildNumber                    : 
Caption                        : 2.14.0
CodeSet                        : 
CurrentLanguage                : en|US|iso8859-1
Description                    : 2.14.0
EmbeddedControllerMajorVersion : 255
EmbeddedControllerMinorVersion : 255
IdentificationCode             : 
InstallableLanguages           : 1
InstallDate                    : 
LanguageEdition                : 
ListOfLanguages                : {en|US|iso8859-1}
Manufacturer                   : Dell Inc.
Name                           : 2.14.0
OtherTargetOS                  : 
PrimaryBIOS                    : True
ReleaseDate                    : 20211216000000.000000+000
SerialNumber                   : GC70G73
SMBIOSBIOSVersion              : 2.14.0
SMBIOSMajorVersion             : 3
SMBIOSMinorVersion             : 2
SMBIOSPresent                  : True
SoftwareElementID              : 2.14.0
SoftwareElementState           : 3
Status                         : OK
SystemBiosMajorVersion         : 2
SystemBiosMinorVersion         : 14
TargetOperatingSystem          : 0
Version                        : DELL   - 1072009


#############################################################
# Get folder utilization for a given directory.
#
dir -path C:\home -file -recurse -force | 
measure-object length -sum -max -average | 
Select-Object @{name="Total Files";Expression={$_.count}},
@{name="Largest File(MB)";Expression={"{0:F2}" -f ($_.maximum/1MB)}},
@{name="Average Size(MB)";Expression={"{0:F2}" -f ($_.average/1MB)}},
@{name="Total Size(MB)";Expression={"{0:F2}" -f ($_.sum/1MB)}}

############################################################# 
# Get event log utilization for remote computers defined in $computers. The remote computers must be running PowerShell v3 or later.
#
gcim Win32_NTEventLogFile <#-computer $computers#> -filter  "NumberOfRecords > 0" | 
Select-Object @{Name="Computername";Expression={$_.CSName}},
LogFileName,
NumberOfRecords,
@{Name="Size(KB)";Expression={$_.FileSize/1kb}},
@{Name="MaxSize(KB)";Expression={($_.MaxFileSize/1KB) -as [int]}}, 
@{name="PercentUsed";Expression={[math]::round(($_.filesize/$_.maxFileSize)*100,2)}} | Sort Computername,PercentUsed | 
Format-Table -GroupBy Computername -property LogFileName,NumberOfRecords,*Size*,PercentUsed

#############################################################
# Get free space for drive C on the local computer formatted in GB
#
(gcim win32_logicaldisk -filter "deviceid =  C: ").FreeSpace/1gb
#or use the PSDrive
(gdr c).Free/1gb


##################################################################
# Out String 
# Use the Width parameter to prevent truncation.

PS> @{TestKey = ('x' * 200)} | Out-String
Name                           Value
----                           -----
TestKey                        xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx...

PS> @{TestKey = ('x' * 200)} | Out-String -Width 250
Name                           Value
----                           -----
TestKey                        xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx

##################################################################
# Out-file
# Set file output width for entire scope
 $PSDefaultParameterValues['out-file:width'] = 2000

####################################################################
# Send output to a file in ASCII format
# https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.utility/out-file?view=powershell-7.2
$Procs = Get-Process
Out-File -FilePath .\Process.txt -InputObject $Procs -Encoding ASCII -Width 50


#############################################################
# Get a date string in the format year-month-day-hour-min-second. The abbreviations in the format string are case-sensitive.
#
get-date -format yyyyMMddhhmmss

#############################################################
# Get the last time your computer booted. Can be modified to query remote computers.
#
(gcim win32_operatingsystem).LastBootUpTime
# or modify to get uptime
(get-date) - ((gcim win32_operatingsystem).LastBootUpTime)

#############################################################
# Get configured TrustedHosts.
#
(get-wsmaninstance wsman/config/client).trustedhosts

#############################################################
# Get all drives identified by a standard drive letter. Im suppressing errors to ignore non-existent drive letters.
#
get-volume -driveletter (97..122) -ErrorAction SilentlyContinue

#############################################################
# Get total physical memory formatted as GB.
#
gcim win32_computersystem <#-computer SRV1,SRV2 #> | Select PSComputername,@{Name="Memory";Expression={$_.TotalPhysicalMemory/1GB -as [int]}}

#############################################################
# Get IPv4 addresses on your local adapters.
#
Get-NetIPAddress -AddressFamily IPv4 | where-object IPAddress -notmatch "^(169)|(127)" | Sort-Object IPAddress | select IPaddress,Interface*
# or all ip-addresses
Get-NetIPAddress -AddressFamily IPv4 | Sort-Object IPAddress | select IPaddress,Interface* 

#############################################################
# Find all processes that use a given module (dll). You can filter by the dll name or use part of a path.
#
get-process | Where { $_.Modules.filename -match "netapi32.dll"}

#############################################################
# Gwt Process Owner
$proc=Get-CimInstance Win32_Process -Filter "name like 'notepad%'"
Invoke-CimMethod -InputObject $proc -MethodName GetOwner

oreach($proc in Get-CimInstance Win32_Process -Filter "name like 'k%'") { Invoke-CimMethod -InputObject $proc -MethodName GetOwner }
Domain  ReturnValue User  PSComputerName
------  ----------- ----  --------------
                  2
                  2
WIN11-2           0 alexe

PS C:\home\src\Scripts> Get-CimInstance Win32_Process -Filter "name like 'k%'" | fl *


ProcessName                : kpm_service.exe
Handles                    : 435
VM                         : 156045312
WS                         : 30523392
Path                       : 
Caption                    : kpm_service.exe
Description                : kpm_service.exe
InstallDate                : 
Name                       : kpm_service.exe
Status                     : 
CreationClassName          : Win32_Process
CreationDate               : 4/27/2022 8:31:45 AM
CSCreationClassName        : Win32_ComputerSystem
CSName                     : WIN11-2
ExecutionState             : 
Handle                     : 5432
KernelModeTime             : 21875000
OSCreationClassName        : Win32_OperatingSystem
OSName                     : Microsoft Windows 11 Pro|C:\Windows|\Device\Harddisk1\Partition4
Priority                   : 8
TerminationDate            : 
UserModeTime               : 139218750
WorkingSetSize             : 30523392
CommandLine                : 
ExecutablePath             : 
HandleCount                : 435
MaximumWorkingSetSize      : 
MinimumWorkingSetSize      : 
OtherOperationCount        : 45169
OtherTransferCount         : 563233
PageFaults                 : 305543
PageFileUsage              : 11260
ParentProcessId            : 1580
PeakPageFileUsage          : 21976
PeakVirtualSize            : 171053056
PeakWorkingSetSize         : 41452
PrivatePageCount           : 11530240
ProcessId                  : 5432
QuotaNonPagedPoolUsage     : 29
QuotaPagedPoolUsage        : 183
QuotaPeakNonPagedPoolUsage : 148
QuotaPeakPagedPoolUsage    : 185
ReadOperationCount         : 14576
ReadTransferCount          : 1371332836
SessionId                  : 0
ThreadCount                : 16
VirtualSize                : 156045312
WindowsVersion             : 10.0.22000
WriteOperationCount        : 188
WriteTransferCount         : 2649694
PSComputerName             : 
CimClass                   : root/cimv2:Win32_Process
CimInstanceProperties      : {Caption, Description, InstallDate, Name…}
CimSystemProperties        : Microsoft.Management.Infrastructure.CimSystemProperties

ProcessName                : ksde.exe
Handles                    : 812
VM                         : 229888000
WS                         : 16125952
Path                       : 
Caption                    : ksde.exe
Description                : ksde.exe
InstallDate                : 
Name                       : ksde.exe
Status                     : 
CreationClassName          : Win32_Process
CreationDate               : 4/27/2022 8:34:46 AM
CSCreationClassName        : Win32_ComputerSystem
CSName                     : WIN11-2
ExecutionState             : 
Handle                     : 2868
KernelModeTime             : 66718750
OSCreationClassName        : Win32_OperatingSystem
OSName                     : Microsoft Windows 11 Pro|C:\Windows|\Device\Harddisk1\Partition4
Priority                   : 8
TerminationDate            : 
UserModeTime               : 53750000
WorkingSetSize             : 16125952
CommandLine                : 
ExecutablePath             : 
HandleCount                : 812
MaximumWorkingSetSize      : 
MinimumWorkingSetSize      : 
OtherOperationCount        : 72986
OtherTransferCount         : 2887767
PageFaults                 : 132915
PageFileUsage              : 32420
ParentProcessId            : 1580
PeakPageFileUsage          : 35180
PeakVirtualSize            : 246943744
PeakWorkingSetSize         : 50864
PrivatePageCount           : 33198080
ProcessId                  : 2868
QuotaNonPagedPoolUsage     : 4226
QuotaPagedPoolUsage        : 259
QuotaPeakNonPagedPoolUsage : 4632
QuotaPeakPagedPoolUsage    : 278
ReadOperationCount         : 5634
ReadTransferCount          : 6398276
SessionId                  : 0
ThreadCount                : 33
VirtualSize                : 229888000
WindowsVersion             : 10.0.22000
WriteOperationCount        : 21304
WriteTransferCount         : 13608052
PSComputerName             : 
CimClass                   : root/cimv2:Win32_Process
CimInstanceProperties      : {Caption, Description, InstallDate, Name…}
CimSystemProperties        : Microsoft.Management.Infrastructure.CimSystemProperties

ProcessName                : ksdeui.exe
Handles                    : 373
VM                         : 143912960
WS                         : 4820992
Path                       : C:\Program Files (x86)\Kaspersky Lab\Kaspersky VPN 5.3\ksdeui.exe
Caption                    : ksdeui.exe
Description                : ksdeui.exe
InstallDate                : 
Name                       : ksdeui.exe
Status                     : 
CreationClassName          : Win32_Process
CreationDate               : 4/27/2022 8:34:54 AM
CSCreationClassName        : Win32_ComputerSystem
CSName                     : WIN11-2
ExecutionState             : 
Handle                     : 12148
KernelModeTime             : 13125000
OSCreationClassName        : Win32_OperatingSystem
OSName                     : Microsoft Windows 11 Pro|C:\Windows|\Device\Harddisk1\Partition4
Priority                   : 8
TerminationDate            : 
UserModeTime               : 11250000
WorkingSetSize             : 4820992
CommandLine                : "C:\Program Files (x86)\Kaspersky Lab\Kaspersky VPN 5.3\ksdeui.exe" -hidden
ExecutablePath             : C:\Program Files (x86)\Kaspersky Lab\Kaspersky VPN 5.3\ksdeui.exe
HandleCount                : 373
MaximumWorkingSetSize      : 1380
MinimumWorkingSetSize      : 200
OtherOperationCount        : 906
OtherTransferCount         : 3426
PageFaults                 : 19384
PageFileUsage              : 8920
ParentProcessId            : 2868
PeakPageFileUsage          : 9264
PeakVirtualSize            : 150032384
PeakWorkingSetSize         : 21660
PrivatePageCount           : 9134080
ProcessId                  : 12148
QuotaNonPagedPoolUsage     : 20
QuotaPagedPoolUsage        : 199
QuotaPeakNonPagedPoolUsage : 22
QuotaPeakPagedPoolUsage    : 201
ReadOperationCount         : 11
ReadTransferCount          : 172440
SessionId                  : 1
ThreadCount                : 6
VirtualSize                : 143912960
WindowsVersion             : 10.0.22000
WriteOperationCount        : 0
WriteTransferCount         : 0
PSComputerName             : 
CimClass                   : root/cimv2:Win32_Process
CimInstanceProperties      : {Caption, Description, InstallDate, Name…}
CimSystemProperties        : Microsoft.Management.Infrastructure.CimSystemProperties


#############################################################
# Group process names and report memory
# get-process is gps
get-process | Group-Object name, {[int]($_.WorkingSet / 1MB)} -NoElement | sort name
gps | Group-Object {[int]($_.WorkingSet / 1MB)},name -NoElement | sort name

#############################################################
# Get cmdlets by using a parameter name and type
#  
Get-Command -ParameterName *Auth* -ParameterType AuthenticationMechanism | format-table Name, Definition

#############################################################
# Get a GUI interface for any PowerShell cmdlet
Show-Command Get-Service

############################################################# 
# Get event logs changed during 4 hours
get-winevent -listlog * -ea 0 | where-object {$_.recordcount -gt 0 -and $_.LastWriteTime -gt ((Get-Date).AddHours(-4))}
(get-winevent -listlog * -ea 0 | where-object {$_.recordcount -gt 0 -and $_.LastWriteTime -gt ((Get-Date).AddHours(-4))}).LogName

############################################################# 
# Get error and warnings event during last 2 hours in 'System','Application','Setup','Security' logs
Get-WinEvent -FilterHashtable @{LogName=('System','Application','Setup','Security'); Level=(0,1,2,3); StartTime=((Get-Date).AddHours(-2))} -ErrorAction Ignore | sort-Object ProviderName,TimeCreated

#############################################################
# List the error events during last 2 hours
#
(get-winevent -FilterHashtable @{Logname = (get-winevent -listlog * -ea 0 | where-object {$_.recordcount -gt 0 -and $_.LastWriteTime -gt ((Get-Date).AddHours(-4))}).LogName;Level=(0,1,2); StartTime=((Get-Date).AddHours(-2))}) | sort-Object -Descending TimeCreated,ProviderName

#############################################################
# Since PowerShell Core and PowerShell 7 do not include the Get-Eventlog cmdlet, heres a one-liner to list the last 10 errors in the System event log. A level value of 3 will give you warnings.
#
get-winevent -FilterHashtable @{Logname = 'System';Level=2} -MaxEvents 10 | sort-Object ProviderName,TimeCreated



#############################################################
# List all PowerShell profile script settings. You will see different values for different hosts, such as the PowerShell ISE, as well as between Windows PowerShell and PowerShell 7.
#
$profile | select *host* | format-list

#############################################################
# Show what PowerShell profile scripts exist.
#
($profile.psobject.properties).where({$_.name -ne 'length'}).where({Test-Path $_.value }) | Select-Object Name,Value

#############################################################
# Get the current date and time formatted as UTC time.
#
(get-date).ToUniversalTime()
# or pretty it up
"$((get-date).ToUniversalTime()) UTC"
"$((Get-Date).ToUniversalTime().tolongdatestring()) UTC"

#############################################################
# Get a formatted report of all commands with a synopsis.
#
(Get-Command).where({ $_.source -match "Wdac"}) | Sort-Object Source, CommandType, Name | Format-Table -AutoSize -GroupBy Source -Property CommandType, Name, 
    @{Name = "Synopsis"; Width=100; Expression = {(Get-Help $_.name).Synopsis  -replace "`r",'' -replace "`n",'' -replace '\s+',' '}} #  -replace '(?<=.{100}).+' 

(Get-Command).where({ $_.source }) | Format-Table -AutoSize -Property Source, CommandType, @{Name="Synopsis";Width=100;Expression={(Get-Help $_.name).Synopsis  -replace "[`r`n]",'' -replace '\s+',' '}} > all_commands.txt

#############################################################
# How long has your PowerShell session been running?
#
(Get-Date) - (get-process -id $pid).starttime


#############################################################
# OS Info - Users, Groups Services
#
 ([ADSI] "WinNT://$Env:ComputerName").Children | select SchemaClassName,Name,Path

#############################################################
# User Properties
#

([ADSI] "WinNT://$Env:ComputerName").Children | where { $_.SchemaClassName -eq 'User' }  | % {
    $hTbl=$_;
    "`n{0,35} : {1}" -f "UserName", $hTbl.Name.Value
    ForEach( $Prop in ($hTbl | Get-Member -MemberType Property).Name ) {
        try { if ($hTbl.$Prop) { $Val=[string]$hTbl.$Prop; if (($Val.Length -gt 0) -and ($Prop -ne "Name") ) { "{0,35} : {1}" -f $Prop, $(switch ($Key) { default { "$($hTbl.$Prop)"}; } ) } } } finally {}
    }
}

#############################################################
# User Accounts
#
# gcim win32_UserAccount | select *
 Get-LocalUser
 gcim win32_UserAccount | Format-Table -autosize Name,Caption,AccountType,SID,Domain,LocalAccount,Description
 gcim win32_UserAccount | Format-Table -autosize @{n='UserName';e={$_.Caption}},@{n='Local';e={if($_.LocalAccount -eq 'True') {'Yes'} else {'No'} }},Description
 gcim win32_UserAccount | Format-Table -autosize @{n='UserName';e={$_.Caption}},@{n='Local';e={if($_.LocalAccount -eq 'True') {'Yes'} else {'No'} }},Description,CimInstanceProperties,CimSystemProperties

 gcim win32_UserAccount | select-object -expand CimInstanceProperties

([ADSI] "WinNT://$Env:ComputerName")).Chidren | select SchemaClassName,Name,Path

([ADSI] "WinNT://$Env:ComputerName").Children | where { $_SchemaClassName -eq 'User' }  | % {
    $hTbl=$_; 
     "`n{0,35} : {1}" -f "UserName", $hTbl.Name.Value
     ForEach( $Key in $hTbl.Keys ) {
         $Val=$hTbl.$Key; if (($Val.Length -gt 0) -and ($Key -ne "Name") ) { "{0,35} : {1}" -f $key, $(switch ($key) { LoginHours {"tbd"}; default { "$($hTbl.$key)"}; } ) }
     }
} 


ForEach ( $Usr in ([ADSI] "WinNT://$env:computername") | where { $_.psbase.schemaclassname -match 'user' } ) {
     # $hTbl=$Usr.PsBase.Properties
     $hTbl=$Usr
     "`n{0,35} : {1}" -f "UserName", $hTbl.Name.Value
     ForEach( $Key in $hTbl.Keys ) {
         $Val=$hTbl.$Key; if (($Val.Length -gt 0) -and ($Key -ne "Name") ) { "{0,35} : {1}" -f $key, $(switch ($key) { LoginHours {"tbd"}; default { "$($hTbl.$key)"}; } ) }
     }
}

([ADSI] "WinNT://WORKGROUP/WIN11-2/alexe") | select *
([ADSI] "WinNT://WORKGROUP/WIN11-2/alexe").PsBase | select *
([ADSI] "WinNT://WORKGROUP/WIN11-2/alexe").PsBase.Properties

([ADSI] "WinNT://WORKGROUP/WIN11-2/Administrator").PsBase.Properties
([ADSI] "WinNT://WORKGROUP/WIN11-2/Guest").PsBase
([ADSI] "WinNT://WORKGROUP/WIN11-2/DefaultAccount").PsBase
([ADSI] "WinNT://WORKGROUP/WIN11-2/WDAGUtilityAccount").PsBase


 ([ADSI] "WinNT://WIN11-2").psbase.Children | where { $_.psbase.schemaclassname -match 'user' } |  <#Format-Table#> Select-Object -property `
             @{Name='Name';Expression= { $_.name }},`
             @{Name='Fullname';Expression= { $_.Fullname }},`
             @{Name='Description';Expression= { $_.Description }},`
             @{Name='AutoUnlockInterval';Expression= { $_.AutoUnlockInterval }},`
             @{Name='BadPasswordAttempts';Expression= { $_.BadPasswordAttempts }},`
             @{Name='HomeDirDrive';Expression= { $_.HomeDirDrive }},`
             @{Name='HomeDirectory';Expression= { $_.HomeDirectory }},`
             @{Name='LastLogin';Expression= { $_.LastLogin }},`
             @{Name='LockoutObservationInterval';Expression= { $_.LockoutObservationInterval }},`
             @{Name='LoginHours';Expression= { $_.LoginHours }},`
             @{Name='LoginScript';Expression= { $_.LoginScript }},`
             @{Name='MaxBadPasswordsAllowed';Expression= { $_.MaxBadPasswordsAllowed }},`
             @{Name='MaxPasswordAge';Expression= { $_.MaxPasswordAge }},`
             @{Name='MaxStorage';Expression= { $_.MaxStorage }},`
             @{Name='MinPasswordAge';Expression= { $_.MinPasswordAge }},`
             @{Name='MinPasswordLength';Expression= { $_.MinPasswordLength }},`
             @{Name='objectSid';Expression= { $_.objectSid }},`
             @{Name='Parameters';Expression= { $_.Parameters }},`
             @{Name='PasswordAge';Expression= { $_.PasswordAge }},`
             @{Name='PasswordExpired';Expression= { $_.PasswordExpired }},`
             @{Name='PasswordHistoryLength';Expression= { $_.PasswordHistoryLength }},`
             @{Name='PrimaryGroupID';Expression= { $_.PrimaryGroupID }},`
             @{Name='Profile';Expression= { $_.Profile }},`
             @{Name='UserFlags';Expression= { $_.UserFlags }}

#############################################################
# User LastLogin
# 
([ADSI] "WinNT://WORKGROUP/WIN11-2/alexe").LastLogin

#############################################################
# Recently Created User Accounts
# 
 
 wmic useraccount
 wmic useraccount where disabled='FALSE'
 wmic useraccount where disabled='FALSE' get sid

 whoami /all
$Prop=([ADSI] "WinNT://WORKGROUP/WIN11-2/Administrator").PsBase.Properties; 
" ** {0,31} : {1} **" -f "User", $Prop.Name.Value; 
$Prop.Keys | % { $k=$_;$v=$Prop.$k.value;$t=$v.GetType();switch($t) { int {$v=$v.ToString()}; string { if ($k -eq "Name") {$k="-";} }; default {$v="tbd"}}; if($k -ne "-") { "{0,35} : {1}" -f "$k($t)",$v }  }


#############################################################
# Get Data Type Members and Properites
# 
 
'value members: {0}' -f "$($parameter.Value | Get-Member)"
# value members: bool Equals(System.Object obj) int GetHashCode() type GetType() string ToString() System.Collections.ObjectModel.Collection[string] Aliases {get;} System.Collections.ObjectModel.Collection[System.Attribute] Attributes {get;} bool IsDynamic {get;set;} string Name {get;set;} System.Collections.Generic.Dictionary[string,System.Management.Automation.ParameterSetMetadata] ParameterSets {get;} type ParameterType {get;set;} bool SwitchParameter {get;}
'value values: {0}' -f "$($parameter.Value | select-object *)"
# value values: @{Name=Arg1; ParameterType=System.Object; ParameterSets=System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterSetMetadata]; IsDynamic=False; Aliases=System.Collections.ObjectModel.Collection`1[System.String]; Attributes=System.Collections.ObjectModel.Collection`1[System.Attribute]; SwitchParameter=False}    
 
'properties: {0}' -f "$(  (([ADSI] "WinNT://WORKGROUP/WIN11-2/Administrator").PsBase.Properties | Get-Member -MemberType Property).Name )"
# properties: Count IsFixedSize IsReadOnly IsSynchronized Keys PropertyNames SyncRoot Values

'methods: {0}' -f "$(  (([ADSI] "WinNT://WORKGROUP/WIN11-2/Administrator").PsBase.Properties | Get-Member -MemberType method ).Name -join('() ') )()"
# methods: Add() Clear() Contains() CopyTo() Equals() GetEnumerator() GetHashCode() GetType() Remove() ToString()

'all members: {0}' -f "$(  ([ADSI] "WinNT://WORKGROUP/WIN11-2/Administrator").PsBase.Properties | Get-Member  )"
# all members: void IDictionary.Add(System.Object key, System.Object value) void IDictionary.Clear() bool Contains(string propertyName), bool IDictionary.Contains(System.Object key) void CopyTo(System.DirectoryServices.PropertyValueCollection[] array, int index), void ICollection.CopyTo(array array, int index) bool Equals(System.Object obj) System.Collections.IDictionaryEnumerator GetEnumerator(), System.Collections.IDictionaryEnumerator IDictionary.GetEnumerator(), System.Collections.IEnumerator IEnumerable.GetEnumerator() int GetHashCode() type GetType() void IDictionary.Remove(System.Object key) string ToString() System.DirectoryServices.PropertyValueCollection Item(string propertyName) {get;}, System.Object IDictionary.Item(System.Object key) {get;set;} int Count {get;} bool IsFixedSize {get;} bool IsReadOnly {get;} bool IsSynchronized {get;} System.Collections.ICollection Keys {get;} System.Collections.ICollection PropertyNames {get;} System.Object SyncRoot {get;} System.Collections.ICollection Values {get;}


# ([ADSI] "WinNT://WORKGROUP/WIN11-2/Administrator").PsBase.Properties | Get-Member -MemberType Properties
#   TypeName: System.DirectoryServices.PropertyCollection
# Name           MemberType Definition
# ----           ---------- ----------
# Count          Property   int Count {get;}
# ...

#############################################################
# Collect information about computer
# https://docs.microsoft.com/en-us/powershell/scripting/samples/collecting-information-about-computers?view=powershell-7.2
#
Get-CimInstance -ClassName Win32_OperatingSystem | Select-Object -expand CimInstanceProperties | Sort-Object Name |  Format-Table Name,Value,Flags

#############################################################
# Search Commands and Modules by Verbs
# https://docs.microsoft.com/en-us/powershell/scripting/samples/using-format-commands-to-change-output-view?view=powershell-7.2
Get-Command -Verb Format -Module Microsoft.PowerShell.Utility
Get-Command -Verb Format | Format-Table -Wrap -AutoSize CommandType, Name, Source, @{n='Definition';e={$_.Definition -replace("`n","") }}


#############################################################
# Install/Unistall module
# 
Install-Module -Name PSDesiredStateConfiguration -AllowPrerelease
Uninstall-Module -Name PSDesiredStateConfiguration


#############################################################
# Find module
# 
Find-Module Azure*
Get-InstalledModule PSDesiredStateConfiguration
Get-InstalledModule PSDesiredStateConfiguration | select *
$env:PSModulePath -split ';' | Get-ChildItem -ea 0 | where {$_.FullName -like '*PSDesiredStateConfiguration*'} | select -first 2 FullName, Attributes, CreationTime, LastAccessTime, LastWriteTime, Mode, LinkTarget
Get-ChildItem ($env:PSModulePath -split ';') 'PSDesiredStateConfiguration' -Recurse


#########################################################
# Get the time and date as a string of numbers by using PowerShell
Get-Date -format "MM_dd_yyyy-HH_MM_ss"
04_28_2022-01_04_11


#############################################################
# Find file
# 
Get-ChildItem ($env:PSModulePath -split ';') 'PSDesiredStateConfiguration' -Recurse
Get-ChildItem C:\ 'PSDesiredStateConfiguration*' -Recurse -ea 0
Get-ChildItem C:\ 'PsGetSid*' -Recurse -ea 0

#############################################################
# Find files created during last 60 days, aka newer than 60 days 
# 
$limit = (Get-Date).AddDays(-60)
$path = "Y:"
Get-ChildItem -Path $path -Recurse -Force | Where-Object { !$_.PSIsContainer -and $_.CreationTime -gt $limit }

#############################################################
# Find files accessed during last 60 dayss
# 
$limit = (Get-Date).AddDays(-60)
$path = "Y:\"
# LastAccessTime # LastWriteTime
Get-ChildItem -Path $path -Recurse -Force | Where-Object { !$_.PSIsContainer -and $_.LastAccessTime -gt $limit }


#############################################################
# Delete files and empty folders older than 150 days
# 
$limit = (Get-Date).AddDays(-150)
$path = "C:\Some\Path"
# Delete files older than the $limit.
Get-ChildItem -Path $path -Recurse -Force | Where-Object { !$_.PSIsContainer -and $_.CreationTime -lt $limit } | Remove-Item -Force -WhatIf
# Delete any empty directories left behind after deleting the old files.
Get-ChildItem -Path $path -Recurse -Force | Where-Object { $_.PSIsContainer -and (Get-ChildItem -Path $_.FullName -Recurse -Force | Where-Object { !$_.PSIsContainer }) -eq $null } | Remove-Item -Force -Recurse -WhatIf

#############################################################
# Get Event by RecID and Proiders
# Get-EventRecId <RecId>,<Providers>
# 
function Get-EventRecId {
    Param($RecId=11035, $Providers=('Service Control Manager'))
    $eNo=0; $EVENTS=Get-WinEvent -ProviderName $Providers -FilterXPath "*[System[EventRecordID=$RecId]]" -maxevent 100 -ea 0; $eTot=$EVENTS.Count
    "RecID: $RecId; Providers:$($Providers -join('; ')); Total: $eTot Event$(($eTot -ne 1)?'s':'') "
    if ($eTot) {
        foreach ($E in $EVENTS) {
            $pad=1;$eNo++; $E.ToXml() -replace("><",">`n<") -replace("^<Event","<Event #$eNo of $(($EVENTS).Count)") -split("`n") |
            % { $str=$_; if($str -match "^</.*>") {$pad-=2} ; "{0,$pad}{1}" -f "","$str"; if( -not ($str -replace "'[^']+'","'X'" -replace '"[^"]+"','"X"' -match "<[^>]*>[^<]*</[^ ].*>|<.*/>|^</.*>")) {$pad+=2} }
        }
        "RecID: $RecId; Providers:$Providers; Total: $eNo Event$(($eNo -ne 1)?'s':'') "
    }
}

#############################################################
# UserName
# 
$env:UserName

#############################################################
# ComputerName
# 
$env:ComputerName

#############################################################
# 32/64 bit
# 
[Environment]::Is64BitProcess

#############################################################
# PowerShell Version
# 
$PSVersionTable.PSVersion


#############################################################
# Print HashTable or Dictoionary
# 
"HashTable[$($HashTable.Count)]: $($HashTable.Keys| ForEach-Object { "$_=$($HashTable.$_ -join ',')" })"
"PSBoundParameters[$($PSBoundParameters.Count)]: $($PSBoundParameters.Keys| ForEach-Object { "[$_]='$($PSBoundParameters.$_)'" })"
[string[]] $l_array = ($PSBoundParameters | Out-String -Stream) -ne '' | select-object -Skip 2; write-output "PSBoundParameters[$(($l_array).Length)]: $($l_array -join '; ')"


#############################################################
# Print Array
# 
"args[$(($args).Length)]: $($args -join '; ')""args[$(($args).Length)]: $($args -join '; ')"


#############################################################
# Convert to XML
# 
( Get-WinEvent -ProviderName 'Service Control Manager' -FilterXPath "*[System[EventRecordID=11035]]" -maxevent 2 -ea 0) | ConvertTo-Xml -As "String" -Depth 3

Get-WinEvent -ProviderName 'Service Control Manager' -FilterXPath "*[System[EventRecordID=11035]]" -maxevent 2 -ea 0 | % {$_.ToXml() -replace("><",">`n<")}
    
$RecId=11035; $Prvds=('Service Control Manager'); $eNo=0; $EVENTS=Get-WinEvent -ProviderName $Prvds -FilterXPath "*[System[EventRecordID=$RecId]]" -maxevent 100 -ea 0; $EVENTS | % {$pad=1;$eNo++; $_.ToXml() -replace("><",">`n<") -replace("^<Event","<Event #$eNo of $(($EVENTS).Count)") -split("`n")} |
  % { $str=$_; if($str -match "^</.*>") {$pad-=2} ; "{0,$pad}{1}" -f "","$str"; if( -not ($str -replace "'[^']+'","'X'" -replace '"[^"]+"','"X"' -match "<[^>]*>[^<]*</[^ ].*>|<.*/>|^</.*>")) {$pad+=2} }; "Total: $eNo Event$(($eNo -ne 1)?'s':'') "


#############################################################
# Convert to Json
# 
( Get-WinEvent -ProviderName 'Service Control Manager' -FilterXPath "*[System[EventRecordID=11035]]" -maxevent 2 -ea 0) | ConvertTo-Json 
( Get-WinEvent -ProviderName 'Service Control Manager' -FilterXPath "*[System[EventRecordID=11035]]" -maxevent 2 -ea 0) | ConvertTo-Json -Compress


#############################################################
# Enable execution of scripts
# Error: "execution of scripts is disabled on this system."
#
# https://stackoverflow.com/questions/4037939/powershell-says-execution-of-scripts-is-disabled-on-this-system

# As an Administrator, you can set the execution policy by typing this into your PowerShell window:
Set-ExecutionPolicy RemoteSigned
# You can bypass this policy for a single file by adding -ExecutionPolicy Bypass when running PowerShell
powershell -ExecutionPolicy Bypass -File script.ps1


################################################################
# Provider Drives
#

PS C:\home\src\Scripts>  Get-PSDrive

Name           Used (GB)     Free (GB) Provider      Root                                                                                                                                                                                 CurrentLocation
----           ---------     --------- --------      ----                                                                                                                                                                                 --------------- 
Alias                                  Alias
C                 946.72       8366.76 FileSystem    C:\                                                                                                                                                                                 home\src\Scripts 
Cert                                   Certificate   \
D                 198.23       2567.74 FileSystem    D:\
E                 286.54       9027.45 FileSystem    E:\
Env                                    Environment
Function                               Function
HKCU                                   Registry      HKEY_CURRENT_USER
HKLM                                   Registry      HKEY_LOCAL_MACHINE
Temp              946.72       8366.76 FileSystem    C:\Users\alexe\AppData\Local\Temp\
Variable                               Variable
W                1664.76        165.06 FileSystem    \\WDMyCloudEX4\v1-media
WSMan                                  WSMan
X                1736.47         93.35 FileSystem    \\WDMyCloudEX4\v2-media
Y                1056.32        773.50 FileSystem    \\WDMyCloudEX4\v3-data
Z                1769.24         60.58 FileSystem    \\WDMyCloudEX4\v4-data


#################################################################
# Registry Value Entries
#

$RegistryPath = 'HKCU:\Software\CommunityBlog\Scripts'
$Name         = 'Version'
$Value        = '42'

PS C:\home\src\Scripts> New-ItemProperty -Path $RegistryPath -Name $Name -Value $Value -PropertyType DWORD -Force 
New-ItemProperty: Cannot find path 'HKCU:\Software\CommunityBlog\Scripts' because it does not exist.


#################################################################
# Registry Value Entries
#
$RegistryPath = 'HKCU:\Software\CommunityBlog\Scripts'
$Name         = 'Version'
$Value        = '42'
# Create the key if it does not exist
If (-NOT (Test-Path $RegistryPath)) {
  New-Item -Path $RegistryPath -Force | Out-Null
}  
# Now set the value
New-ItemProperty -Path $RegistryPath -Name $Name -Value $Value -PropertyType DWORD -Force


##############################################################
# NIC
#############################################################

#####################
# How to rename Nic

PS C:\home\src\Scripts> Get-NetAdapter

Name                      InterfaceDescription                    ifIndex Status       MacAddress             LinkSpeed
----                      --------------------                    ------- ------       ----------             ---------
Ethernet Kaspersky        Kaspersky Security Data Escort Adapter       23 Disconnected 00-FF-F1-45-1B-15       100 Mbps
vEthernet (Default Switc… Hyper-V Virtual Ethernet Adapter             58 Up           00-15-5D-23-EC-74        10 Gbps
Wi-Fi                     TP-Link Wireless MU-MIMO USB Adapter         18 Up           98-48-27-E3-58-63       585 Mbps
Bluetooth Network Connec… Bluetooth Device (Personal Area Networ…      12 Disconnected 00-1A-7D-B2-10-86         3 Mbps
Ethernet                  Intel(R) Ethernet Connection (5) I219-…       8 Up           A4-BB-6D-D6-F4-75         1 Gbps
VirtualBox Host-Only Net… VirtualBox Host-Only Ethernet Adapter         4 Up           0A-00-27-00-00-04         1 Gbps

# Admin required
 Get-NetAdapter -InterfaceIndex 16 | Rename-NetAdapter -NewName 'Sales iSCSI VLAN' Get-NetAdapter -InterfaceIndex 16 | Rename-NetAdapter -NewName 'Sales iSCSI VLAN'



################################################
# How to send output to a file

Get-Process -Name p* | Set-Content -Path C:\home\tmp\Get-Process.txt
Get-Content -Path C:\home\tmp\Get-Process.txt
<#
System.Diagnostics.Process (plugins_nms)
System.Diagnostics.Process (powershell)
System.Diagnostics.Process (pwsh)
#>

############################################
# Using Out-String
# You can improve the output from Set-Content by using Out-String, like this
Get-Process -Name p* | Out-String | Set-Content C:\home\tmp\Get-Process.txt
Get-Content -Path C:\home\tmp\Get-Process.txt
<#
 NPM(K)    PM(M)      WS(M)     CPU(s)      Id  SI ProcessName
 ------    -----      -----     ------      --  -- -----------
     12     2.68       9.50       0.75   17880   1 plugins_nms
     30    65.43      78.31       0.73   16208   1 powershell
    111   125.08     177.77      11.59   18120   1 pwsh
#>

############################################
# Using Out-File 
# The Out-File cmdlet gives you control over the output that PowerShell composes and sends to the file.
Get-Process -Name p* | Out-File -Path C:\home\tmp\Get-Process.txt
Get-Content -Path C:\home\tmp\Get-Process.txt

# The Redirection Operators
# There are two PowerShell operators you can use to redirect output: > and >>. 
# The > operator is equivalent to Out-File while >> is equivalent to Out-File -Append. 

# Using .NET Classes

# BinaryWriter – Writes primitive types in binary to a stream.
# StreamWriter – writes characters to a stream in a particular encoding.
# StringWriter – writes information to a string. With this class, Powershell stores the string information in a StringBuilder object.
# Of these three, the class you are most likely to use to send output to a file is the StreamWriter class. Like this:
# Get the directories in C:\
$Dirs = Get-ChildItem -Path C:\ -Directory
# Open a stream writer
$File   = 'C:\Foo\Dirs.txt'
$Stream = [System.IO.StreamWriter]::new($File)
# Write the folder names for these folders to the file
foreach($Dir in $Dirs) {
  $Stream.WriteLine($Dir.FullName)
}
# Close the stream
$Stream.Close()

# You can use Get-Content to view the generated content, like this:

PS> Get-Content -Path c:\Foo\Dirs.txt
C:\AUDIT
C:\Boot
C:\Foo
C:\inetpub
C:\jea
C:\NVIDIA
C:\PerfLogs
C:\Program Files
C:\Program Files (x86)
C:\PSDailyBuild
C:\ReskitApp
C:\Temp
C:\Users
C:\WINDOWS



###################################
## New-TemporaryFile Cmdlet

$File = New-TemporaryFile      # 	Create
Remove-Item -path $File -force # 	Remove

"$($Env:temp)\tmp$([convert]::tostring((get-random 65535),16).padleft(4,'0')).tmp"

Function New-TemporaryFolder {
    # Make a new folder based upon a TempFileName
    $T="$($Env:temp)\tmp$([convert]::tostring((get-random 65535),16).padleft(4,'0')).tmp"
    New-Item -ItemType Directory -Path $T
}



###################################
## Is the User an Administrator?

$Me = whoami.exe
$Admins = Get-LocalGroupMember -Name Administrators | Select-Object -ExpandProperty name
if ($Admins -Contains $Me) { "$Me is a local administrator"}  else { "$Me is NOT a local administrator"}


###################################
## String to Upper case
$Prompt = 'Enter Your Name In ALL Upper Case'
$Prompt
$Prompt.ToUpper()

#####################################
# Read File

$ColorsText = @'
violet
indigo
blue
green
yellow
orange
red
'@

$FileName="C:\home\tmp\ColorsFoo.txt"
$ColorsText | Out-File -Path $FileName
Get-ChildItem -Path $FileName

# Once you have created the file, you can get the contents and display it, like this:
$ArrayData = Get-Content -Path $FileName
$ArrayData

$FileName="C:\home\tmp\ColorsFoo.txt"
$ArrayData = Get-Content -Path $FileName
$Length = $ArrayData.count
"There are $Length lines in the file"
$ArrayData

# Printing a text file bottom up
$Line=1
1..$Length | ForEach-Object {$ArrayData[-$Line]; $Line++}


############################################################
## Skip the beginning and ending of a file by using 
#
$a= Get-Content "C:\home\tmp\ColorsFoo.txt"
$array = @()
for ($i = 0; $i -lt $a.Count; $i++) {
    If ($a[$i] -cmatch "indigo" ) { $start=$i }
    If ($a[$i] -cmatch "orange")  { $end=$i }
}
$a[$start .. $end]


##############################################################
# Use a regular expression pattern to replace nonalphabetic characters with dots
$string = "abcdefg12345HIJKLMNOP!@#$%qrs)(*&^TUVWXyz"
$pattern = "[^a-zA-Z]"
$string -replace $pattern, "."


################################################
# gps

gps | group name | ? count -gt 1 | ft



################################################
# display a percentage that has two decimal places
'{0:p2}' -f (1/10)

################################################
# Remove trailing space from a string 
$Data="           Look at all of this wasted space on my screen. "
$Data
$Data.trim()
$Data.trimstart()
$Data.trimend()

################################################
# Set the color of the progress bar with PowerShell
$Host.PrivateData.ProgressBackgroundColor="Green" 
$Host.PrivateData.ProgressForegroundColor="Black"

################################################
# List all available CIM classes by using 
Get-CimClass Win32*Disk*

################################################
# escape characters in a string using regular expressions
PS C:\home\src\Scripts> [regex]::escape('something. in here (needs) escaping')
something\.\ in\ here\ \(needs\)\ escaping

################################################
# How to detect phone numbers using regular expressions
$phoneornot = @('780-123-4567', '780 321 6548', 'notme', 'this is 2 num')
$phones = [regex]::matches(($phoneornot -replace '\D', ''),'\b(\d{10})\b')
$phones.value

###############################################
# list all possible colors in the console
[System.Enum]::getvalues([System.ConsoleColor])

##################################
# Find all devices connected to a computer
Get-PnpDevice -PresentOnly

####################################################
#  devices attached to the system 
# https://devblogs.microsoft.com/scripting/passing-through-devices-to-hyper-v-vms-by-using-discrete-device-assignment/

Get-PnpDevice -PresentOnly | Sort-Object -Property Class


Status     Class           FriendlyName                                                                     InstanceId
------     -----           ------------                                                                     ----------
OK         System          Microsoft Hyper-V Virtual Machine Bus Provider                                   ROOT\VMBUS\0000
OK         System          Microsoft Hypervisor Service                                                     ROOT\HVSERVICE…
OK         Net             Hyper-V Virtual Switch Extension Adapter                                         ROOT\VMS_VSMP\…
OK         Net             Hyper-V Virtual Switch Extension Adapter #2                                      ROOT\VMS_VSMP\…
OK         Net             Hyper-V Virtual Switch Extension Adapter #3                                      ROOT\VMS_VSMP\…
OK         System          Microsoft Hyper-V Virtualization Infrastructure Driver                           ROOT\VID\0000
OK         System          Microsoft Hyper-V PCI Server                                                     ROOT\VPCIVSP\0…
OK         System          Microsoft Hyper-V Virtual Disk Server                                            ROOT\STORVSP\0…

# Mount
# Now we need to dismount the device from the host by using the Dismount-VmHostAssignableDevice cmdlet. 
# To specify a location of the device, we need to get a specific property that is not presented in the device object by using Get-PnpDeviceProperty.
locationPath = (Get-PnpDeviceProperty -KeyName DEVPKEY_Device_LocationPaths -InstanceId $dev.InstanceId).Data[0] Dismount-VmHostAssignableDevice -LocationPath $locationPath -Force –Verbose

Now if you refresh the device object, you can see that something changed: Device is described as “Dismounted”:
(Get-PnpDevice -PresentOnly).Where{ $_.InstanceId -like $instanceId }


# The last step is to attach an assignable device to the VM by using Add-VMAssignableDevice like this:
Add-VMAssignableDevice -VM $vm -LocationPath $locationPath –Verbose

# Dynamic memory is allowed, but minimum and startup memory have to be equal. Let’s fix it, and finally attach our device.
Set-VM -VM $vm -DynamicMemory -MemoryMinimumBytes 1024MB -MemoryMaximumBytes 4096MB -MemoryStartupBytes 1024MB -AutomaticStopAction TurnOff 
Add-VMAssignableDevice -VM $vm -LocationPath $locationPath –Verbose

#####
# Full code
$vmName = 'VMDDA0'
$instanceId = '*VEN_168C&DEV_002B*'
$ErrorActionPreference = 'Stop'
$vm = Get-VM -Name $vmName
$dev = (Get-PnpDevice -PresentOnly).Where{ $_.InstanceId -like $instanceId } 
if (@($dev).Count -eq 1) {
    Disable-PnpDevice -InstanceId $dev.InstanceId -Confirm:$false
    $locationPath = (Get-PnpDeviceProperty -KeyName DEVPKEY_Device_LocationPaths -InstanceId $dev.InstanceId).Data[0]
    Dismount-VmHostAssignableDevice -LocationPath $locationPath -Force -Verbose
    Set-VM -VM $vm -DynamicMemory -MemoryMinimumBytes 1024MB -MemoryMaximumBytes 4096MB -MemoryStartupBytes 1024MB -AutomaticStopAction TurnOff
# If you want to play with GPUs: 
# Set-VM -VM $vm -StaticMemory -MemoryStartupBytes 4096MB -AutomaticStopAction TurnOff
# Set-VM -VM $vm -GuestControlledCacheTypes $true -LowMemoryMappedIoSpace 2048MB -HighMemoryMappedIoSpace 4096MB -Verbose
    Add-VMAssignableDevice -VM $vm -LocationPath $locationPath -Verbose
} else {
    $dev | Sort-Object -Property Class | Format-Table -AutoSize Write-Error -Message ('Number of devices: {0}' -f @($dev).Count)
}

# Restore configuration
# Remove all devices from a single VM 
Remove-VMAssignableDevice -VMName VMDDA0 -Verbose
# Return all to host 
Get-VMHostAssignableDevice | Mount-VmHostAssignableDevice -Verbose
# Enable it in devmgmt.msc 
(Get-PnpDevice -PresentOnly).Where{ $_.InstanceId -match 'VEN_168C&DEV_002B' } | Enable-PnpDevice -Confirm:$false -Verbose


##########################################################################
# Changing Drive Letter
$Drive = Get-CimInstance -ClassName Win32_Volume -Filter "DriveLetter = 'M:'"
$Drive | Set-CimInstance -Property @{DriveLetter ='X:'}


#############################################################################
# Service Owner
 Get-Service workstation | select  Username,Starttype,BinaryPathName
 Get-Service * | ft DisplayName,Username,Status,Starttype,BinaryPathName,Description